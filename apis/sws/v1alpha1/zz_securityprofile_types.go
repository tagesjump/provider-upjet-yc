// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AuthoritiesInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthoritiesObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthoritiesParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthorityAuthoritiesInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthorityAuthoritiesObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthorityAuthoritiesParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthorityInitParameters struct {
	Authorities []AuthoritiesInitParameters `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type AuthorityObservation struct {
	Authorities []AuthoritiesObservation `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type AuthorityParameters struct {

	// +kubebuilder:validation:Optional
	Authorities []AuthoritiesParameters `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type ConditionAuthorityInitParameters struct {
	Authorities []AuthorityAuthoritiesInitParameters `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type ConditionAuthorityObservation struct {
	Authorities []AuthorityAuthoritiesObservation `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type ConditionAuthorityParameters struct {

	// +kubebuilder:validation:Optional
	Authorities []AuthorityAuthoritiesParameters `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type ConditionHTTPMethodInitParameters struct {
	HTTPMethods []HTTPMethodHTTPMethodsInitParameters `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type ConditionHTTPMethodObservation struct {
	HTTPMethods []HTTPMethodHTTPMethodsObservation `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type ConditionHTTPMethodParameters struct {

	// +kubebuilder:validation:Optional
	HTTPMethods []HTTPMethodHTTPMethodsParameters `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type ConditionHeadersInitParameters struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Value []HeadersValueInitParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type ConditionHeadersObservation struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Value []HeadersValueObservation `json:"value,omitempty" tf:"value,omitempty"`
}

type ConditionHeadersParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value []HeadersValueParameters `json:"value" tf:"value,omitempty"`
}

type ConditionInitParameters struct {
	Authority []AuthorityInitParameters `json:"authority,omitempty" tf:"authority,omitempty"`

	HTTPMethod []HTTPMethodInitParameters `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	Headers []HeadersInitParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	RequestURI []RequestURIInitParameters `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	SourceIP []SourceIPInitParameters `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type ConditionObservation struct {
	Authority []AuthorityObservation `json:"authority,omitempty" tf:"authority,omitempty"`

	HTTPMethod []HTTPMethodObservation `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	Headers []HeadersObservation `json:"headers,omitempty" tf:"headers,omitempty"`

	RequestURI []RequestURIObservation `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	SourceIP []SourceIPObservation `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type ConditionParameters struct {

	// +kubebuilder:validation:Optional
	Authority []AuthorityParameters `json:"authority,omitempty" tf:"authority,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPMethod []HTTPMethodParameters `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	// +kubebuilder:validation:Optional
	Headers []HeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	RequestURI []RequestURIParameters `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	// +kubebuilder:validation:Optional
	SourceIP []SourceIPParameters `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type ConditionRequestURIInitParameters struct {
	Path []RequestURIPathInitParameters `json:"path,omitempty" tf:"path,omitempty"`

	Queries []RequestURIQueriesInitParameters `json:"queries,omitempty" tf:"queries,omitempty"`
}

type ConditionRequestURIObservation struct {
	Path []RequestURIPathObservation `json:"path,omitempty" tf:"path,omitempty"`

	Queries []RequestURIQueriesObservation `json:"queries,omitempty" tf:"queries,omitempty"`
}

type ConditionRequestURIParameters struct {

	// +kubebuilder:validation:Optional
	Path []RequestURIPathParameters `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Queries []RequestURIQueriesParameters `json:"queries,omitempty" tf:"queries,omitempty"`
}

type ConditionSourceIPInitParameters struct {
	GeoIPMatch []SourceIPGeoIPMatchInitParameters `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	GeoIPNotMatch []SourceIPGeoIPNotMatchInitParameters `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	IPRangesMatch []SourceIPIPRangesMatchInitParameters `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	IPRangesNotMatch []SourceIPIPRangesNotMatchInitParameters `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type ConditionSourceIPObservation struct {
	GeoIPMatch []SourceIPGeoIPMatchObservation `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	GeoIPNotMatch []SourceIPGeoIPNotMatchObservation `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	IPRangesMatch []SourceIPIPRangesMatchObservation `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	IPRangesNotMatch []SourceIPIPRangesNotMatchObservation `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type ConditionSourceIPParameters struct {

	// +kubebuilder:validation:Optional
	GeoIPMatch []SourceIPGeoIPMatchParameters `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	// +kubebuilder:validation:Optional
	GeoIPNotMatch []SourceIPGeoIPNotMatchParameters `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	IPRangesMatch []SourceIPIPRangesMatchParameters `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	// +kubebuilder:validation:Optional
	IPRangesNotMatch []SourceIPIPRangesNotMatchParameters `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type GeoIPMatchInitParameters struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPMatchObservation struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPMatchParameters struct {

	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPNotMatchInitParameters struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPNotMatchObservation struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPNotMatchParameters struct {

	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type HTTPMethodHTTPMethodsInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HTTPMethodHTTPMethodsObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HTTPMethodHTTPMethodsParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HTTPMethodInitParameters struct {
	HTTPMethods []HTTPMethodsInitParameters `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type HTTPMethodObservation struct {
	HTTPMethods []HTTPMethodsObservation `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type HTTPMethodParameters struct {

	// +kubebuilder:validation:Optional
	HTTPMethods []HTTPMethodsParameters `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type HTTPMethodsInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HTTPMethodsObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HTTPMethodsParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HeadersInitParameters struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Value []ValueInitParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type HeadersObservation struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Value []ValueObservation `json:"value,omitempty" tf:"value,omitempty"`
}

type HeadersParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value []ValueParameters `json:"value" tf:"value,omitempty"`
}

type HeadersValueInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HeadersValueObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HeadersValueParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type IPRangesMatchInitParameters struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesMatchObservation struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesMatchParameters struct {

	// +kubebuilder:validation:Optional
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesNotMatchInitParameters struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesNotMatchObservation struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesNotMatchParameters struct {

	// +kubebuilder:validation:Optional
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type PathInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type PathObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type PathParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type QueriesInitParameters struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value []QueriesValueInitParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type QueriesObservation struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value []QueriesValueObservation `json:"value,omitempty" tf:"value,omitempty"`
}

type QueriesParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value []QueriesValueParameters `json:"value" tf:"value,omitempty"`
}

type QueriesValueInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type QueriesValueObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type QueriesValueParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIInitParameters struct {
	Path []PathInitParameters `json:"path,omitempty" tf:"path,omitempty"`

	Queries []QueriesInitParameters `json:"queries,omitempty" tf:"queries,omitempty"`
}

type RequestURIObservation struct {
	Path []PathObservation `json:"path,omitempty" tf:"path,omitempty"`

	Queries []QueriesObservation `json:"queries,omitempty" tf:"queries,omitempty"`
}

type RequestURIParameters struct {

	// +kubebuilder:validation:Optional
	Path []PathParameters `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Queries []QueriesParameters `json:"queries,omitempty" tf:"queries,omitempty"`
}

type RequestURIPathInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIPathObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIPathParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIQueriesInitParameters struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value []RequestURIQueriesValueInitParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type RequestURIQueriesObservation struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value []RequestURIQueriesValueObservation `json:"value,omitempty" tf:"value,omitempty"`
}

type RequestURIQueriesParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value []RequestURIQueriesValueParameters `json:"value" tf:"value,omitempty"`
}

type RequestURIQueriesValueInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIQueriesValueObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIQueriesValueParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RuleConditionInitParameters struct {
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	Condition []ConditionInitParameters `json:"condition,omitempty" tf:"condition,omitempty"`
}

type RuleConditionObservation struct {
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	Condition []ConditionObservation `json:"condition,omitempty" tf:"condition,omitempty"`
}

type RuleConditionParameters struct {

	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// +kubebuilder:validation:Optional
	Condition []ConditionParameters `json:"condition,omitempty" tf:"condition,omitempty"`
}

type SecurityProfileInitParameters struct {
	CaptchaID *string `json:"captchaId,omitempty" tf:"captcha_id,omitempty"`

	CloudID *string `json:"cloudId,omitempty" tf:"cloud_id,omitempty"`

	DefaultAction *string `json:"defaultAction,omitempty" tf:"default_action,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/resourcemanager/v1alpha1.Folder
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	SecurityRule []SecurityRuleInitParameters `json:"securityRule,omitempty" tf:"security_rule,omitempty"`
}

type SecurityProfileObservation struct {
	CaptchaID *string `json:"captchaId,omitempty" tf:"captcha_id,omitempty"`

	CloudID *string `json:"cloudId,omitempty" tf:"cloud_id,omitempty"`

	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	DefaultAction *string `json:"defaultAction,omitempty" tf:"default_action,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	SecurityRule []SecurityRuleObservation `json:"securityRule,omitempty" tf:"security_rule,omitempty"`
}

type SecurityProfileParameters struct {

	// +kubebuilder:validation:Optional
	CaptchaID *string `json:"captchaId,omitempty" tf:"captcha_id,omitempty"`

	// +kubebuilder:validation:Optional
	CloudID *string `json:"cloudId,omitempty" tf:"cloud_id,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultAction *string `json:"defaultAction,omitempty" tf:"default_action,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/resourcemanager/v1alpha1.Folder
	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityRule []SecurityRuleParameters `json:"securityRule,omitempty" tf:"security_rule,omitempty"`
}

type SecurityRuleInitParameters struct {
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	RuleCondition []RuleConditionInitParameters `json:"ruleCondition,omitempty" tf:"rule_condition,omitempty"`

	SmartProtection []SmartProtectionInitParameters `json:"smartProtection,omitempty" tf:"smart_protection,omitempty"`
}

type SecurityRuleObservation struct {
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	RuleCondition []RuleConditionObservation `json:"ruleCondition,omitempty" tf:"rule_condition,omitempty"`

	SmartProtection []SmartProtectionObservation `json:"smartProtection,omitempty" tf:"smart_protection,omitempty"`
}

type SecurityRuleParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// +kubebuilder:validation:Optional
	RuleCondition []RuleConditionParameters `json:"ruleCondition,omitempty" tf:"rule_condition,omitempty"`

	// +kubebuilder:validation:Optional
	SmartProtection []SmartProtectionParameters `json:"smartProtection,omitempty" tf:"smart_protection,omitempty"`
}

type SmartProtectionConditionInitParameters struct {
	Authority []ConditionAuthorityInitParameters `json:"authority,omitempty" tf:"authority,omitempty"`

	HTTPMethod []ConditionHTTPMethodInitParameters `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	Headers []ConditionHeadersInitParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	RequestURI []ConditionRequestURIInitParameters `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	SourceIP []ConditionSourceIPInitParameters `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type SmartProtectionConditionObservation struct {
	Authority []ConditionAuthorityObservation `json:"authority,omitempty" tf:"authority,omitempty"`

	HTTPMethod []ConditionHTTPMethodObservation `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	Headers []ConditionHeadersObservation `json:"headers,omitempty" tf:"headers,omitempty"`

	RequestURI []ConditionRequestURIObservation `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	SourceIP []ConditionSourceIPObservation `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type SmartProtectionConditionParameters struct {

	// +kubebuilder:validation:Optional
	Authority []ConditionAuthorityParameters `json:"authority,omitempty" tf:"authority,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPMethod []ConditionHTTPMethodParameters `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	// +kubebuilder:validation:Optional
	Headers []ConditionHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	RequestURI []ConditionRequestURIParameters `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	// +kubebuilder:validation:Optional
	SourceIP []ConditionSourceIPParameters `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type SmartProtectionInitParameters struct {
	Condition []SmartProtectionConditionInitParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type SmartProtectionObservation struct {
	Condition []SmartProtectionConditionObservation `json:"condition,omitempty" tf:"condition,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type SmartProtectionParameters struct {

	// +kubebuilder:validation:Optional
	Condition []SmartProtectionConditionParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type SourceIPGeoIPMatchInitParameters struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPGeoIPMatchObservation struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPGeoIPMatchParameters struct {

	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPGeoIPNotMatchInitParameters struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPGeoIPNotMatchObservation struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPGeoIPNotMatchParameters struct {

	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPIPRangesMatchInitParameters struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPIPRangesMatchObservation struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPIPRangesMatchParameters struct {

	// +kubebuilder:validation:Optional
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPIPRangesNotMatchInitParameters struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPIPRangesNotMatchObservation struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPIPRangesNotMatchParameters struct {

	// +kubebuilder:validation:Optional
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPInitParameters struct {
	GeoIPMatch []GeoIPMatchInitParameters `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	GeoIPNotMatch []GeoIPNotMatchInitParameters `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	IPRangesMatch []IPRangesMatchInitParameters `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	IPRangesNotMatch []IPRangesNotMatchInitParameters `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type SourceIPObservation struct {
	GeoIPMatch []GeoIPMatchObservation `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	GeoIPNotMatch []GeoIPNotMatchObservation `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	IPRangesMatch []IPRangesMatchObservation `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	IPRangesNotMatch []IPRangesNotMatchObservation `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type SourceIPParameters struct {

	// +kubebuilder:validation:Optional
	GeoIPMatch []GeoIPMatchParameters `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	// +kubebuilder:validation:Optional
	GeoIPNotMatch []GeoIPNotMatchParameters `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	IPRangesMatch []IPRangesMatchParameters `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	// +kubebuilder:validation:Optional
	IPRangesNotMatch []IPRangesNotMatchParameters `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type ValueInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type ValueObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type ValueParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

// SecurityProfileSpec defines the desired state of SecurityProfile
type SecurityProfileSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SecurityProfileParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SecurityProfileInitParameters `json:"initProvider,omitempty"`
}

// SecurityProfileStatus defines the observed state of SecurityProfile.
type SecurityProfileStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SecurityProfileObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// SecurityProfile is the Schema for the SecurityProfiles API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type SecurityProfile struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SecurityProfileSpec   `json:"spec"`
	Status            SecurityProfileStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SecurityProfileList contains a list of SecurityProfiles
type SecurityProfileList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SecurityProfile `json:"items"`
}

// Repository type metadata.
var (
	SecurityProfile_Kind             = "SecurityProfile"
	SecurityProfile_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SecurityProfile_Kind}.String()
	SecurityProfile_KindAPIVersion   = SecurityProfile_Kind + "." + CRDGroupVersion.String()
	SecurityProfile_GroupVersionKind = CRDGroupVersion.WithKind(SecurityProfile_Kind)
)

func init() {
	SchemeBuilder.Register(&SecurityProfile{}, &SecurityProfileList{})
}
