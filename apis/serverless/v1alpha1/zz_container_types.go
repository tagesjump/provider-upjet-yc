

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"

)




type ConnectivityInitParameters struct {


// Network the revision will have access to
NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`
}


type ConnectivityObservation struct {


// Network the revision will have access to
NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`
}


type ConnectivityParameters struct {


// Network the revision will have access to
// +kubebuilder:validation:Optional
NetworkID *string `json:"networkId" tf:"network_id,omitempty"`
}


type ContainerInitParameters struct {


// Concurrency of Yandex Cloud Serverless Container
Concurrency *float64 `json:"concurrency,omitempty" tf:"concurrency,omitempty"`

// Network access. If specified the revision will be attached to specified network
Connectivity []ConnectivityInitParameters `json:"connectivity,omitempty" tf:"connectivity,omitempty"`

// Core fraction (0...100) of the Yandex Cloud Serverless Container
CoreFraction *float64 `json:"coreFraction,omitempty" tf:"core_fraction,omitempty"`

Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

// Description of the Yandex Cloud Serverless Container
Description *string `json:"description,omitempty" tf:"description,omitempty"`

// Execution timeout in seconds (duration format) for Yandex Cloud Serverless Container
ExecutionTimeout *string `json:"executionTimeout,omitempty" tf:"execution_timeout,omitempty"`

// Folder ID for the Yandex Cloud Serverless Container
// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/resourcemanager/v1alpha1.Folder
FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

// Reference to a Folder in resourcemanager to populate folderId.
// +kubebuilder:validation:Optional
FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

// Selector for a Folder in resourcemanager to populate folderId.
// +kubebuilder:validation:Optional
FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

// Revision deployment image for Yandex Cloud Serverless Container
Image []ImageInitParameters `json:"image,omitempty" tf:"image,omitempty"`

// A set of key/value label pairs to assign to the Yandex Cloud Serverless Container
// +mapType=granular
Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

// Options for logging from Yandex Cloud Serverless Container
LogOptions []LogOptionsInitParameters `json:"logOptions,omitempty" tf:"log_options,omitempty"`

// Memory in megabytes (aligned to 128MB) for Yandex Cloud Serverless Container
// Container memory in megabytes, should be aligned to 128
Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

// Mounts for Yandex Cloud Serverless Container
Mounts []MountsInitParameters `json:"mounts,omitempty" tf:"mounts,omitempty"`

// Yandex Cloud Serverless Container name
Name *string `json:"name,omitempty" tf:"name,omitempty"`

// Provision policy. If specified the revision will have prepared instances
ProvisionPolicy []ProvisionPolicyInitParameters `json:"provisionPolicy,omitempty" tf:"provision_policy,omitempty"`

// Secrets for Yandex Cloud Serverless Container
Secrets []SecretsInitParameters `json:"secrets,omitempty" tf:"secrets,omitempty"`

// Service account ID for Yandex Cloud Serverless Container
// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/iam/v1alpha1.ServiceAccount
// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
ServiceAccountID *string `json:"serviceAccountId,omitempty" tf:"service_account_id,omitempty"`

// Reference to a ServiceAccount in iam to populate serviceAccountId.
// +kubebuilder:validation:Optional
ServiceAccountIDRef *v1.Reference `json:"serviceAccountIdRef,omitempty" tf:"-"`

// Selector for a ServiceAccount in iam to populate serviceAccountId.
// +kubebuilder:validation:Optional
ServiceAccountIDSelector *v1.Selector `json:"serviceAccountIdSelector,omitempty" tf:"-"`

// (DEPRECATED, use mounts.0.object_storage instead) Storage mounts for Yandex Cloud Serverless Container
StorageMounts []StorageMountsInitParameters `json:"storageMounts,omitempty" tf:"storage_mounts,omitempty"`
}


type ContainerObservation struct {


// Concurrency of Yandex Cloud Serverless Container
Concurrency *float64 `json:"concurrency,omitempty" tf:"concurrency,omitempty"`

// Network access. If specified the revision will be attached to specified network
Connectivity []ConnectivityObservation `json:"connectivity,omitempty" tf:"connectivity,omitempty"`

// Core fraction (0...100) of the Yandex Cloud Serverless Container
CoreFraction *float64 `json:"coreFraction,omitempty" tf:"core_fraction,omitempty"`

Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

// Creation timestamp of the Yandex Cloud Serverless Container
CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

// Description of the Yandex Cloud Serverless Container
Description *string `json:"description,omitempty" tf:"description,omitempty"`

// Execution timeout in seconds (duration format) for Yandex Cloud Serverless Container
ExecutionTimeout *string `json:"executionTimeout,omitempty" tf:"execution_timeout,omitempty"`

// Folder ID for the Yandex Cloud Serverless Container
FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

// Secret's id
ID *string `json:"id,omitempty" tf:"id,omitempty"`

// Revision deployment image for Yandex Cloud Serverless Container
Image []ImageObservation `json:"image,omitempty" tf:"image,omitempty"`

// A set of key/value label pairs to assign to the Yandex Cloud Serverless Container
// +mapType=granular
Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

// Options for logging from Yandex Cloud Serverless Container
LogOptions []LogOptionsObservation `json:"logOptions,omitempty" tf:"log_options,omitempty"`

// Memory in megabytes (aligned to 128MB) for Yandex Cloud Serverless Container
// Container memory in megabytes, should be aligned to 128
Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

// Mounts for Yandex Cloud Serverless Container
Mounts []MountsObservation `json:"mounts,omitempty" tf:"mounts,omitempty"`

// Yandex Cloud Serverless Container name
Name *string `json:"name,omitempty" tf:"name,omitempty"`

// Provision policy. If specified the revision will have prepared instances
ProvisionPolicy []ProvisionPolicyObservation `json:"provisionPolicy,omitempty" tf:"provision_policy,omitempty"`

// Last revision ID of the Yandex Cloud Serverless Container
RevisionID *string `json:"revisionId,omitempty" tf:"revision_id,omitempty"`

// Secrets for Yandex Cloud Serverless Container
Secrets []SecretsObservation `json:"secrets,omitempty" tf:"secrets,omitempty"`

// Service account ID for Yandex Cloud Serverless Container
ServiceAccountID *string `json:"serviceAccountId,omitempty" tf:"service_account_id,omitempty"`

// (DEPRECATED, use mounts.0.object_storage instead) Storage mounts for Yandex Cloud Serverless Container
StorageMounts []StorageMountsObservation `json:"storageMounts,omitempty" tf:"storage_mounts,omitempty"`

// Invoke URL for the Yandex Cloud Serverless Container
URL *string `json:"url,omitempty" tf:"url,omitempty"`
}


type ContainerParameters struct {


// Concurrency of Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
Concurrency *float64 `json:"concurrency,omitempty" tf:"concurrency,omitempty"`

// Network access. If specified the revision will be attached to specified network
// +kubebuilder:validation:Optional
Connectivity []ConnectivityParameters `json:"connectivity,omitempty" tf:"connectivity,omitempty"`

// Core fraction (0...100) of the Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
CoreFraction *float64 `json:"coreFraction,omitempty" tf:"core_fraction,omitempty"`

// +kubebuilder:validation:Optional
Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

// Description of the Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
Description *string `json:"description,omitempty" tf:"description,omitempty"`

// Execution timeout in seconds (duration format) for Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
ExecutionTimeout *string `json:"executionTimeout,omitempty" tf:"execution_timeout,omitempty"`

// Folder ID for the Yandex Cloud Serverless Container
// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/resourcemanager/v1alpha1.Folder
// +kubebuilder:validation:Optional
FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

// Reference to a Folder in resourcemanager to populate folderId.
// +kubebuilder:validation:Optional
FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

// Selector for a Folder in resourcemanager to populate folderId.
// +kubebuilder:validation:Optional
FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

// Revision deployment image for Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
Image []ImageParameters `json:"image,omitempty" tf:"image,omitempty"`

// A set of key/value label pairs to assign to the Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
// +mapType=granular
Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

// Options for logging from Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
LogOptions []LogOptionsParameters `json:"logOptions,omitempty" tf:"log_options,omitempty"`

// Memory in megabytes (aligned to 128MB) for Yandex Cloud Serverless Container
// Container memory in megabytes, should be aligned to 128
// +kubebuilder:validation:Optional
Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

// Mounts for Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
Mounts []MountsParameters `json:"mounts,omitempty" tf:"mounts,omitempty"`

// Yandex Cloud Serverless Container name
// +kubebuilder:validation:Optional
Name *string `json:"name,omitempty" tf:"name,omitempty"`

// Provision policy. If specified the revision will have prepared instances
// +kubebuilder:validation:Optional
ProvisionPolicy []ProvisionPolicyParameters `json:"provisionPolicy,omitempty" tf:"provision_policy,omitempty"`

// Secrets for Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
Secrets []SecretsParameters `json:"secrets,omitempty" tf:"secrets,omitempty"`

// Service account ID for Yandex Cloud Serverless Container
// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/iam/v1alpha1.ServiceAccount
// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
// +kubebuilder:validation:Optional
ServiceAccountID *string `json:"serviceAccountId,omitempty" tf:"service_account_id,omitempty"`

// Reference to a ServiceAccount in iam to populate serviceAccountId.
// +kubebuilder:validation:Optional
ServiceAccountIDRef *v1.Reference `json:"serviceAccountIdRef,omitempty" tf:"-"`

// Selector for a ServiceAccount in iam to populate serviceAccountId.
// +kubebuilder:validation:Optional
ServiceAccountIDSelector *v1.Selector `json:"serviceAccountIdSelector,omitempty" tf:"-"`

// (DEPRECATED, use mounts.0.object_storage instead) Storage mounts for Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
StorageMounts []StorageMountsParameters `json:"storageMounts,omitempty" tf:"storage_mounts,omitempty"`
}


type EphemeralDiskInitParameters struct {


// Optional block size of the ephemeral disk in KB
BlockSizeKb *float64 `json:"blockSizeKb,omitempty" tf:"block_size_kb,omitempty"`

// Size of the ephemeral disk in GB
SizeGb *float64 `json:"sizeGb,omitempty" tf:"size_gb,omitempty"`
}


type EphemeralDiskObservation struct {


// Optional block size of the ephemeral disk in KB
BlockSizeKb *float64 `json:"blockSizeKb,omitempty" tf:"block_size_kb,omitempty"`

// Size of the ephemeral disk in GB
SizeGb *float64 `json:"sizeGb,omitempty" tf:"size_gb,omitempty"`
}


type EphemeralDiskParameters struct {


// Optional block size of the ephemeral disk in KB
// +kubebuilder:validation:Optional
BlockSizeKb *float64 `json:"blockSizeKb,omitempty" tf:"block_size_kb,omitempty"`

// Size of the ephemeral disk in GB
// +kubebuilder:validation:Optional
SizeGb *float64 `json:"sizeGb" tf:"size_gb,omitempty"`
}


type ImageInitParameters struct {


// List of arguments for Yandex Cloud Serverless Container
Args []*string `json:"args,omitempty" tf:"args,omitempty"`

// List of commands for Yandex Cloud Serverless Container
Command []*string `json:"command,omitempty" tf:"command,omitempty"`

// Digest of image that will be deployed as Yandex Cloud Serverless Container. If presented, should be equal to digest that will be resolved at server side by URL. Container will be updated on digest change even if image.0.url stays the same. If field not specified then its value will be computed.
Digest *string `json:"digest,omitempty" tf:"digest,omitempty"`

// A set of key/value environment variable pairs for Yandex Cloud Serverless Container
// +mapType=granular
Environment map[string]*string `json:"environment,omitempty" tf:"environment,omitempty"`

// Invoke URL for the Yandex Cloud Serverless Container
URL *string `json:"url,omitempty" tf:"url,omitempty"`

// Working directory for Yandex Cloud Serverless Container
WorkDir *string `json:"workDir,omitempty" tf:"work_dir,omitempty"`
}


type ImageObservation struct {


// List of arguments for Yandex Cloud Serverless Container
Args []*string `json:"args,omitempty" tf:"args,omitempty"`

// List of commands for Yandex Cloud Serverless Container
Command []*string `json:"command,omitempty" tf:"command,omitempty"`

// Digest of image that will be deployed as Yandex Cloud Serverless Container. If presented, should be equal to digest that will be resolved at server side by URL. Container will be updated on digest change even if image.0.url stays the same. If field not specified then its value will be computed.
Digest *string `json:"digest,omitempty" tf:"digest,omitempty"`

// A set of key/value environment variable pairs for Yandex Cloud Serverless Container
// +mapType=granular
Environment map[string]*string `json:"environment,omitempty" tf:"environment,omitempty"`

// Invoke URL for the Yandex Cloud Serverless Container
URL *string `json:"url,omitempty" tf:"url,omitempty"`

// Working directory for Yandex Cloud Serverless Container
WorkDir *string `json:"workDir,omitempty" tf:"work_dir,omitempty"`
}


type ImageParameters struct {


// List of arguments for Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
Args []*string `json:"args,omitempty" tf:"args,omitempty"`

// List of commands for Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
Command []*string `json:"command,omitempty" tf:"command,omitempty"`

// Digest of image that will be deployed as Yandex Cloud Serverless Container. If presented, should be equal to digest that will be resolved at server side by URL. Container will be updated on digest change even if image.0.url stays the same. If field not specified then its value will be computed.
// +kubebuilder:validation:Optional
Digest *string `json:"digest,omitempty" tf:"digest,omitempty"`

// A set of key/value environment variable pairs for Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
// +mapType=granular
Environment map[string]*string `json:"environment,omitempty" tf:"environment,omitempty"`

// Invoke URL for the Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
URL *string `json:"url" tf:"url,omitempty"`

// Working directory for Yandex Cloud Serverless Container
// +kubebuilder:validation:Optional
WorkDir *string `json:"workDir,omitempty" tf:"work_dir,omitempty"`
}


type LogOptionsInitParameters struct {


// Is logging from container disabled
Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

// Log entries are written to default log group for specified folder
FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

// Log entries are written to specified log group
LogGroupID *string `json:"logGroupId,omitempty" tf:"log_group_id,omitempty"`

// Minimum log entry level
MinLevel *string `json:"minLevel,omitempty" tf:"min_level,omitempty"`
}


type LogOptionsObservation struct {


// Is logging from container disabled
Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

// Log entries are written to default log group for specified folder
FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

// Log entries are written to specified log group
LogGroupID *string `json:"logGroupId,omitempty" tf:"log_group_id,omitempty"`

// Minimum log entry level
MinLevel *string `json:"minLevel,omitempty" tf:"min_level,omitempty"`
}


type LogOptionsParameters struct {


// Is logging from container disabled
// +kubebuilder:validation:Optional
Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

// Log entries are written to default log group for specified folder
// +kubebuilder:validation:Optional
FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

// Log entries are written to specified log group
// +kubebuilder:validation:Optional
LogGroupID *string `json:"logGroupId,omitempty" tf:"log_group_id,omitempty"`

// Minimum log entry level
// +kubebuilder:validation:Optional
MinLevel *string `json:"minLevel,omitempty" tf:"min_level,omitempty"`
}


type MountsInitParameters struct {


// One of the available mount types. Disk available during the function execution time
EphemeralDisk []EphemeralDiskInitParameters `json:"ephemeralDisk,omitempty" tf:"ephemeral_disk,omitempty"`

// Mount’s accessibility mode. Valid values are ro and rw
Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

// Path inside the container to access the directory in which the bucket is mounted
MountPointPath *string `json:"mountPointPath,omitempty" tf:"mount_point_path,omitempty"`

// One of the available mount types. Object storage as a mount
ObjectStorage []ObjectStorageInitParameters `json:"objectStorage,omitempty" tf:"object_storage,omitempty"`
}


type MountsObservation struct {


// One of the available mount types. Disk available during the function execution time
EphemeralDisk []EphemeralDiskObservation `json:"ephemeralDisk,omitempty" tf:"ephemeral_disk,omitempty"`

// Mount’s accessibility mode. Valid values are ro and rw
Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

// Path inside the container to access the directory in which the bucket is mounted
MountPointPath *string `json:"mountPointPath,omitempty" tf:"mount_point_path,omitempty"`

// One of the available mount types. Object storage as a mount
ObjectStorage []ObjectStorageObservation `json:"objectStorage,omitempty" tf:"object_storage,omitempty"`
}


type MountsParameters struct {


// One of the available mount types. Disk available during the function execution time
// +kubebuilder:validation:Optional
EphemeralDisk []EphemeralDiskParameters `json:"ephemeralDisk,omitempty" tf:"ephemeral_disk,omitempty"`

// Mount’s accessibility mode. Valid values are ro and rw
// +kubebuilder:validation:Optional
Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

// Path inside the container to access the directory in which the bucket is mounted
// +kubebuilder:validation:Optional
MountPointPath *string `json:"mountPointPath" tf:"mount_point_path,omitempty"`

// One of the available mount types. Object storage as a mount
// +kubebuilder:validation:Optional
ObjectStorage []ObjectStorageParameters `json:"objectStorage,omitempty" tf:"object_storage,omitempty"`
}


type ObjectStorageInitParameters struct {


// Name of the mounting bucket
// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/storage/v1alpha1.Bucket
// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("bucket",false)
Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

// Reference to a Bucket in storage to populate bucket.
// +kubebuilder:validation:Optional
BucketRef *v1.Reference `json:"bucketRef,omitempty" tf:"-"`

// Selector for a Bucket in storage to populate bucket.
// +kubebuilder:validation:Optional
BucketSelector *v1.Selector `json:"bucketSelector,omitempty" tf:"-"`

// Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}


type ObjectStorageObservation struct {


// Name of the mounting bucket
Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

// Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}


type ObjectStorageParameters struct {


// Name of the mounting bucket
// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/storage/v1alpha1.Bucket
// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractParamPath("bucket",false)
// +kubebuilder:validation:Optional
Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

// Reference to a Bucket in storage to populate bucket.
// +kubebuilder:validation:Optional
BucketRef *v1.Reference `json:"bucketRef,omitempty" tf:"-"`

// Selector for a Bucket in storage to populate bucket.
// +kubebuilder:validation:Optional
BucketSelector *v1.Selector `json:"bucketSelector,omitempty" tf:"-"`

// Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
// +kubebuilder:validation:Optional
Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}


type ProvisionPolicyInitParameters struct {


// Minimum number of prepared instances that are always ready to serve requests
MinInstances *float64 `json:"minInstances,omitempty" tf:"min_instances,omitempty"`
}


type ProvisionPolicyObservation struct {


// Minimum number of prepared instances that are always ready to serve requests
MinInstances *float64 `json:"minInstances,omitempty" tf:"min_instances,omitempty"`
}


type ProvisionPolicyParameters struct {


// Minimum number of prepared instances that are always ready to serve requests
// +kubebuilder:validation:Optional
MinInstances *float64 `json:"minInstances" tf:"min_instances,omitempty"`
}


type SecretsInitParameters struct {


// Container's environment variable in which secret's value will be stored
EnvironmentVariable *string `json:"environmentVariable,omitempty" tf:"environment_variable,omitempty"`

// Secret's id
// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/lockbox/v1alpha1.Secret
// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
ID *string `json:"id,omitempty" tf:"id,omitempty"`

// Reference to a Secret in lockbox to populate id.
// +kubebuilder:validation:Optional
IDRef *v1.Reference `json:"idRef,omitempty" tf:"-"`

// Selector for a Secret in lockbox to populate id.
// +kubebuilder:validation:Optional
IDSelector *v1.Selector `json:"idSelector,omitempty" tf:"-"`

// Secret's entries key which value will be stored in environment variable
Key *string `json:"key,omitempty" tf:"key,omitempty"`

// Secret's version id
// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/lockbox/v1alpha1.SecretVersion
// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
VersionID *string `json:"versionId,omitempty" tf:"version_id,omitempty"`

// Reference to a SecretVersion in lockbox to populate versionId.
// +kubebuilder:validation:Optional
VersionIDRef *v1.Reference `json:"versionIdRef,omitempty" tf:"-"`

// Selector for a SecretVersion in lockbox to populate versionId.
// +kubebuilder:validation:Optional
VersionIDSelector *v1.Selector `json:"versionIdSelector,omitempty" tf:"-"`
}


type SecretsObservation struct {


// Container's environment variable in which secret's value will be stored
EnvironmentVariable *string `json:"environmentVariable,omitempty" tf:"environment_variable,omitempty"`

// Secret's id
ID *string `json:"id,omitempty" tf:"id,omitempty"`

// Secret's entries key which value will be stored in environment variable
Key *string `json:"key,omitempty" tf:"key,omitempty"`

// Secret's version id
VersionID *string `json:"versionId,omitempty" tf:"version_id,omitempty"`
}


type SecretsParameters struct {


// Container's environment variable in which secret's value will be stored
// +kubebuilder:validation:Optional
EnvironmentVariable *string `json:"environmentVariable" tf:"environment_variable,omitempty"`

// Secret's id
// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/lockbox/v1alpha1.Secret
// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
// +kubebuilder:validation:Optional
ID *string `json:"id,omitempty" tf:"id,omitempty"`

// Reference to a Secret in lockbox to populate id.
// +kubebuilder:validation:Optional
IDRef *v1.Reference `json:"idRef,omitempty" tf:"-"`

// Selector for a Secret in lockbox to populate id.
// +kubebuilder:validation:Optional
IDSelector *v1.Selector `json:"idSelector,omitempty" tf:"-"`

// Secret's entries key which value will be stored in environment variable
// +kubebuilder:validation:Optional
Key *string `json:"key" tf:"key,omitempty"`

// Secret's version id
// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/lockbox/v1alpha1.SecretVersion
// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
// +kubebuilder:validation:Optional
VersionID *string `json:"versionId,omitempty" tf:"version_id,omitempty"`

// Reference to a SecretVersion in lockbox to populate versionId.
// +kubebuilder:validation:Optional
VersionIDRef *v1.Reference `json:"versionIdRef,omitempty" tf:"-"`

// Selector for a SecretVersion in lockbox to populate versionId.
// +kubebuilder:validation:Optional
VersionIDSelector *v1.Selector `json:"versionIdSelector,omitempty" tf:"-"`
}


type StorageMountsInitParameters struct {


// Name of the mounting bucket
Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

// Path inside the container to access the directory in which the bucket is mounted
MountPointPath *string `json:"mountPointPath,omitempty" tf:"mount_point_path,omitempty"`

// Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

// Mount the bucket in read-only mode
ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}


type StorageMountsObservation struct {


// Name of the mounting bucket
Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

// Path inside the container to access the directory in which the bucket is mounted
MountPointPath *string `json:"mountPointPath,omitempty" tf:"mount_point_path,omitempty"`

// Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

// Mount the bucket in read-only mode
ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}


type StorageMountsParameters struct {


// Name of the mounting bucket
// +kubebuilder:validation:Optional
Bucket *string `json:"bucket" tf:"bucket,omitempty"`

// Path inside the container to access the directory in which the bucket is mounted
// +kubebuilder:validation:Optional
MountPointPath *string `json:"mountPointPath" tf:"mount_point_path,omitempty"`

// Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted
// +kubebuilder:validation:Optional
Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

// Mount the bucket in read-only mode
// +kubebuilder:validation:Optional
ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

// ContainerSpec defines the desired state of Container
type ContainerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider       ContainerParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider       ContainerInitParameters `json:"initProvider,omitempty"`
}

// ContainerStatus defines the observed state of Container.
type ContainerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider          ContainerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion


// Container is the Schema for the Containers API. Allows management of a Yandex Cloud Serverless Container.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type Container struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.image) || (has(self.initProvider) && has(self.initProvider.image))",message="spec.forProvider.image is a required parameter"
// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.memory) || (has(self.initProvider) && has(self.initProvider.memory))",message="spec.forProvider.memory is a required parameter"
// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec              ContainerSpec   `json:"spec"`
	Status            ContainerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ContainerList contains a list of Containers
type ContainerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Container `json:"items"`
}

// Repository type metadata.
var (
	Container_Kind             = "Container"
	Container_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Container_Kind}.String()
	Container_KindAPIVersion   = Container_Kind + "." + CRDGroupVersion.String()
	Container_GroupVersionKind = CRDGroupVersion.WithKind(Container_Kind)
)

func init() {
	SchemeBuilder.Register(&Container{}, &ContainerList{})
}
