// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CaptchaInitParameters struct {
	AllowedSites []*string `json:"allowedSites,omitempty" tf:"allowed_sites,omitempty"`

	ChallengeType *string `json:"challengeType,omitempty" tf:"challenge_type,omitempty"`

	CloudID *string `json:"cloudId,omitempty" tf:"cloud_id,omitempty"`

	Complexity *string `json:"complexity,omitempty" tf:"complexity,omitempty"`

	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/resourcemanager/v1alpha1.Folder
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	OverrideVariant []OverrideVariantInitParameters `json:"overrideVariant,omitempty" tf:"override_variant,omitempty"`

	PreCheckType *string `json:"preCheckType,omitempty" tf:"pre_check_type,omitempty"`

	SecurityRule []SecurityRuleInitParameters `json:"securityRule,omitempty" tf:"security_rule,omitempty"`

	StyleJSON *string `json:"styleJson,omitempty" tf:"style_json,omitempty"`

	TurnOffHostnameCheck *bool `json:"turnOffHostnameCheck,omitempty" tf:"turn_off_hostname_check,omitempty"`
}

type CaptchaObservation struct {
	AllowedSites []*string `json:"allowedSites,omitempty" tf:"allowed_sites,omitempty"`

	ChallengeType *string `json:"challengeType,omitempty" tf:"challenge_type,omitempty"`

	ClientKey *string `json:"clientKey,omitempty" tf:"client_key,omitempty"`

	CloudID *string `json:"cloudId,omitempty" tf:"cloud_id,omitempty"`

	Complexity *string `json:"complexity,omitempty" tf:"complexity,omitempty"`

	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	OverrideVariant []OverrideVariantObservation `json:"overrideVariant,omitempty" tf:"override_variant,omitempty"`

	PreCheckType *string `json:"preCheckType,omitempty" tf:"pre_check_type,omitempty"`

	SecurityRule []SecurityRuleObservation `json:"securityRule,omitempty" tf:"security_rule,omitempty"`

	StyleJSON *string `json:"styleJson,omitempty" tf:"style_json,omitempty"`

	Suspend *bool `json:"suspend,omitempty" tf:"suspend,omitempty"`

	TurnOffHostnameCheck *bool `json:"turnOffHostnameCheck,omitempty" tf:"turn_off_hostname_check,omitempty"`
}

type CaptchaParameters struct {

	// +kubebuilder:validation:Optional
	AllowedSites []*string `json:"allowedSites,omitempty" tf:"allowed_sites,omitempty"`

	// +kubebuilder:validation:Optional
	ChallengeType *string `json:"challengeType,omitempty" tf:"challenge_type,omitempty"`

	// +kubebuilder:validation:Optional
	CloudID *string `json:"cloudId,omitempty" tf:"cloud_id,omitempty"`

	// +kubebuilder:validation:Optional
	Complexity *string `json:"complexity,omitempty" tf:"complexity,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/resourcemanager/v1alpha1.Folder
	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	OverrideVariant []OverrideVariantParameters `json:"overrideVariant,omitempty" tf:"override_variant,omitempty"`

	// +kubebuilder:validation:Optional
	PreCheckType *string `json:"preCheckType,omitempty" tf:"pre_check_type,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityRule []SecurityRuleParameters `json:"securityRule,omitempty" tf:"security_rule,omitempty"`

	// +kubebuilder:validation:Optional
	StyleJSON *string `json:"styleJson,omitempty" tf:"style_json,omitempty"`

	// +kubebuilder:validation:Optional
	TurnOffHostnameCheck *bool `json:"turnOffHostnameCheck,omitempty" tf:"turn_off_hostname_check,omitempty"`
}

type ConditionInitParameters struct {
	Headers []HeadersInitParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	Host []HostInitParameters `json:"host,omitempty" tf:"host,omitempty"`

	SourceIP []SourceIPInitParameters `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`

	URI []URIInitParameters `json:"uri,omitempty" tf:"uri,omitempty"`
}

type ConditionObservation struct {
	Headers []HeadersObservation `json:"headers,omitempty" tf:"headers,omitempty"`

	Host []HostObservation `json:"host,omitempty" tf:"host,omitempty"`

	SourceIP []SourceIPObservation `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`

	URI []URIObservation `json:"uri,omitempty" tf:"uri,omitempty"`
}

type ConditionParameters struct {

	// +kubebuilder:validation:Optional
	Headers []HeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	Host []HostParameters `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	SourceIP []SourceIPParameters `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`

	// +kubebuilder:validation:Optional
	URI []URIParameters `json:"uri,omitempty" tf:"uri,omitempty"`
}

type GeoIPMatchInitParameters struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPMatchObservation struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPMatchParameters struct {

	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPNotMatchInitParameters struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPNotMatchObservation struct {
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPNotMatchParameters struct {

	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type HeadersInitParameters struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Value []ValueInitParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type HeadersObservation struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Value []ValueObservation `json:"value,omitempty" tf:"value,omitempty"`
}

type HeadersParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value []ValueParameters `json:"value" tf:"value,omitempty"`
}

type HostInitParameters struct {
	Hosts []HostsInitParameters `json:"hosts,omitempty" tf:"hosts,omitempty"`
}

type HostObservation struct {
	Hosts []HostsObservation `json:"hosts,omitempty" tf:"hosts,omitempty"`
}

type HostParameters struct {

	// +kubebuilder:validation:Optional
	Hosts []HostsParameters `json:"hosts,omitempty" tf:"hosts,omitempty"`
}

type HostsInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HostsObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HostsParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type IPRangesMatchInitParameters struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesMatchObservation struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesMatchParameters struct {

	// +kubebuilder:validation:Optional
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesNotMatchInitParameters struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesNotMatchObservation struct {
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesNotMatchParameters struct {

	// +kubebuilder:validation:Optional
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type OverrideVariantInitParameters struct {
	ChallengeType *string `json:"challengeType,omitempty" tf:"challenge_type,omitempty"`

	Complexity *string `json:"complexity,omitempty" tf:"complexity,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	PreCheckType *string `json:"preCheckType,omitempty" tf:"pre_check_type,omitempty"`

	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type OverrideVariantObservation struct {
	ChallengeType *string `json:"challengeType,omitempty" tf:"challenge_type,omitempty"`

	Complexity *string `json:"complexity,omitempty" tf:"complexity,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	PreCheckType *string `json:"preCheckType,omitempty" tf:"pre_check_type,omitempty"`

	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type OverrideVariantParameters struct {

	// +kubebuilder:validation:Optional
	ChallengeType *string `json:"challengeType,omitempty" tf:"challenge_type,omitempty"`

	// +kubebuilder:validation:Optional
	Complexity *string `json:"complexity,omitempty" tf:"complexity,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	PreCheckType *string `json:"preCheckType,omitempty" tf:"pre_check_type,omitempty"`

	// +kubebuilder:validation:Optional
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type PathInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type PathObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type PathParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type QueriesInitParameters struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value []QueriesValueInitParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type QueriesObservation struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value []QueriesValueObservation `json:"value,omitempty" tf:"value,omitempty"`
}

type QueriesParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value []QueriesValueParameters `json:"value" tf:"value,omitempty"`
}

type QueriesValueInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type QueriesValueObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type QueriesValueParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type SecurityRuleInitParameters struct {
	Condition []ConditionInitParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	OverrideVariantUUID *string `json:"overrideVariantUuid,omitempty" tf:"override_variant_uuid,omitempty"`

	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`
}

type SecurityRuleObservation struct {
	Condition []ConditionObservation `json:"condition,omitempty" tf:"condition,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	OverrideVariantUUID *string `json:"overrideVariantUuid,omitempty" tf:"override_variant_uuid,omitempty"`

	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`
}

type SecurityRuleParameters struct {

	// +kubebuilder:validation:Optional
	Condition []ConditionParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	OverrideVariantUUID *string `json:"overrideVariantUuid,omitempty" tf:"override_variant_uuid,omitempty"`

	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`
}

type SourceIPInitParameters struct {
	GeoIPMatch []GeoIPMatchInitParameters `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	GeoIPNotMatch []GeoIPNotMatchInitParameters `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	IPRangesMatch []IPRangesMatchInitParameters `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	IPRangesNotMatch []IPRangesNotMatchInitParameters `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type SourceIPObservation struct {
	GeoIPMatch []GeoIPMatchObservation `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	GeoIPNotMatch []GeoIPNotMatchObservation `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	IPRangesMatch []IPRangesMatchObservation `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	IPRangesNotMatch []IPRangesNotMatchObservation `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type SourceIPParameters struct {

	// +kubebuilder:validation:Optional
	GeoIPMatch []GeoIPMatchParameters `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	// +kubebuilder:validation:Optional
	GeoIPNotMatch []GeoIPNotMatchParameters `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	IPRangesMatch []IPRangesMatchParameters `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	// +kubebuilder:validation:Optional
	IPRangesNotMatch []IPRangesNotMatchParameters `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type URIInitParameters struct {
	Path []PathInitParameters `json:"path,omitempty" tf:"path,omitempty"`

	Queries []QueriesInitParameters `json:"queries,omitempty" tf:"queries,omitempty"`
}

type URIObservation struct {
	Path []PathObservation `json:"path,omitempty" tf:"path,omitempty"`

	Queries []QueriesObservation `json:"queries,omitempty" tf:"queries,omitempty"`
}

type URIParameters struct {

	// +kubebuilder:validation:Optional
	Path []PathParameters `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Queries []QueriesParameters `json:"queries,omitempty" tf:"queries,omitempty"`
}

type ValueInitParameters struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type ValueObservation struct {
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type ValueParameters struct {

	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

// CaptchaSpec defines the desired state of Captcha
type CaptchaSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     CaptchaParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider CaptchaInitParameters `json:"initProvider,omitempty"`
}

// CaptchaStatus defines the observed state of Captcha.
type CaptchaStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        CaptchaObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Captcha is the Schema for the Captchas API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type Captcha struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              CaptchaSpec   `json:"spec"`
	Status            CaptchaStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CaptchaList contains a list of Captchas
type CaptchaList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Captcha `json:"items"`
}

// Repository type metadata.
var (
	Captcha_Kind             = "Captcha"
	Captcha_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Captcha_Kind}.String()
	Captcha_KindAPIVersion   = Captcha_Kind + "." + CRDGroupVersion.String()
	Captcha_GroupVersionKind = CRDGroupVersion.WithKind(Captcha_Kind)
)

func init() {
	SchemeBuilder.Register(&Captcha{}, &CaptchaList{})
}
