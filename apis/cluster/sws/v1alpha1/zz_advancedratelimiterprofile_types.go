// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type AdvancedRateLimiterProfileInitParameters struct {

	// (Block List) List of rules.
	// List of rules.
	//
	// ~> Exactly one rule specifier: `static_quota` or `dynamic_quota` should be specified.
	AdvancedRateLimiterRule []AdvancedRateLimiterRuleInitParameters `json:"advancedRateLimiterRule,omitempty" tf:"advanced_rate_limiter_rule,omitempty"`

	// id is used.
	// The `Cloud ID` which resource belongs to. If it is not provided, the default provider `cloud-id` is used.
	CloudID *string `json:"cloudId,omitempty" tf:"cloud_id,omitempty"`

	// (String) The resource description.
	// The resource description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// id is used.
	// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
	// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/cluster/resourcemanager/v1alpha1.Folder
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// (Map of String) A set of key/value label pairs which assigned to resource.
	// A set of key/value label pairs which assigned to resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (String) The resource name.
	// The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AdvancedRateLimiterProfileObservation struct {

	// (Block List) List of rules.
	// List of rules.
	//
	// ~> Exactly one rule specifier: `static_quota` or `dynamic_quota` should be specified.
	AdvancedRateLimiterRule []AdvancedRateLimiterRuleObservation `json:"advancedRateLimiterRule,omitempty" tf:"advanced_rate_limiter_rule,omitempty"`

	// id is used.
	// The `Cloud ID` which resource belongs to. If it is not provided, the default provider `cloud-id` is used.
	CloudID *string `json:"cloudId,omitempty" tf:"cloud_id,omitempty"`

	// (String) The creation timestamp of the resource.
	// The creation timestamp of the resource.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// (String) The resource description.
	// The resource description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// id is used.
	// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Map of String) A set of key/value label pairs which assigned to resource.
	// A set of key/value label pairs which assigned to resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (String) The resource name.
	// The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AdvancedRateLimiterProfileParameters struct {

	// (Block List) List of rules.
	// List of rules.
	//
	// ~> Exactly one rule specifier: `static_quota` or `dynamic_quota` should be specified.
	// +kubebuilder:validation:Optional
	AdvancedRateLimiterRule []AdvancedRateLimiterRuleParameters `json:"advancedRateLimiterRule,omitempty" tf:"advanced_rate_limiter_rule,omitempty"`

	// id is used.
	// The `Cloud ID` which resource belongs to. If it is not provided, the default provider `cloud-id` is used.
	// +kubebuilder:validation:Optional
	CloudID *string `json:"cloudId,omitempty" tf:"cloud_id,omitempty"`

	// (String) The resource description.
	// The resource description.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// id is used.
	// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
	// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/cluster/resourcemanager/v1alpha1.Folder
	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// (Map of String) A set of key/value label pairs which assigned to resource.
	// A set of key/value label pairs which assigned to resource.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (String) The resource name.
	// The resource name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AdvancedRateLimiterRuleInitParameters struct {

	// (String) The resource description.
	// Description of the rule. 0-512 characters long.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
	// This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	// (Block List, Max: 1) Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups. (see below for nested schema)
	// Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups.
	DynamicQuota []DynamicQuotaInitParameters `json:"dynamicQuota,omitempty" tf:"dynamic_quota,omitempty"`

	// (String) The resource name.
	// Name of the rule. The name is unique within the ARL profile. 1-50 characters long.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Number) Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
	// Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// (Block List, Max: 1) Static quota. Counting each request individually. (see below for nested schema)
	// Static quota. Counting each request individually.
	StaticQuota []StaticQuotaInitParameters `json:"staticQuota,omitempty" tf:"static_quota,omitempty"`
}

type AdvancedRateLimiterRuleObservation struct {

	// (String) The resource description.
	// Description of the rule. 0-512 characters long.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
	// This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	// (Block List, Max: 1) Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups. (see below for nested schema)
	// Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups.
	DynamicQuota []DynamicQuotaObservation `json:"dynamicQuota,omitempty" tf:"dynamic_quota,omitempty"`

	// (String) The resource name.
	// Name of the rule. The name is unique within the ARL profile. 1-50 characters long.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Number) Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
	// Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// (Block List, Max: 1) Static quota. Counting each request individually. (see below for nested schema)
	// Static quota. Counting each request individually.
	StaticQuota []StaticQuotaObservation `json:"staticQuota,omitempty" tf:"static_quota,omitempty"`
}

type AdvancedRateLimiterRuleParameters struct {

	// (String) The resource description.
	// Description of the rule. 0-512 characters long.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Boolean) This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
	// This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
	// +kubebuilder:validation:Optional
	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	// (Block List, Max: 1) Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups. (see below for nested schema)
	// Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups.
	// +kubebuilder:validation:Optional
	DynamicQuota []DynamicQuotaParameters `json:"dynamicQuota,omitempty" tf:"dynamic_quota,omitempty"`

	// (String) The resource name.
	// Name of the rule. The name is unique within the ARL profile. 1-50 characters long.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Number) Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
	// Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// (Block List, Max: 1) Static quota. Counting each request individually. (see below for nested schema)
	// Static quota. Counting each request individually.
	// +kubebuilder:validation:Optional
	StaticQuota []StaticQuotaParameters `json:"staticQuota,omitempty" tf:"static_quota,omitempty"`
}

type AuthoritiesInitParameters struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthoritiesObservation struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthoritiesParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthorityAuthoritiesInitParameters struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthorityAuthoritiesObservation struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthorityAuthoritiesParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type AuthorityInitParameters struct {

	// (Block List) (see below for nested schema)
	Authorities []AuthoritiesInitParameters `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type AuthorityObservation struct {

	// (Block List) (see below for nested schema)
	Authorities []AuthoritiesObservation `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type AuthorityParameters struct {

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Authorities []AuthoritiesParameters `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type CharacteristicInitParameters struct {

	// sensitive or case-insensitive keys matching.
	// Determines case-sensitive or case-insensitive keys matching.
	CaseInsensitive *bool `json:"caseInsensitive,omitempty" tf:"case_insensitive,omitempty"`

	// (Block List, Max: 1) Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See Rules for more details. (see below for nested schema)
	// Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
	KeyCharacteristic []KeyCharacteristicInitParameters `json:"keyCharacteristic,omitempty" tf:"key_characteristic,omitempty"`

	// (Block List, Max: 1) Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See Rules for more details. (see below for nested schema)
	// Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
	SimpleCharacteristic []SimpleCharacteristicInitParameters `json:"simpleCharacteristic,omitempty" tf:"simple_characteristic,omitempty"`
}

type CharacteristicObservation struct {

	// sensitive or case-insensitive keys matching.
	// Determines case-sensitive or case-insensitive keys matching.
	CaseInsensitive *bool `json:"caseInsensitive,omitempty" tf:"case_insensitive,omitempty"`

	// (Block List, Max: 1) Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See Rules for more details. (see below for nested schema)
	// Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
	KeyCharacteristic []KeyCharacteristicObservation `json:"keyCharacteristic,omitempty" tf:"key_characteristic,omitempty"`

	// (Block List, Max: 1) Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See Rules for more details. (see below for nested schema)
	// Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
	SimpleCharacteristic []SimpleCharacteristicObservation `json:"simpleCharacteristic,omitempty" tf:"simple_characteristic,omitempty"`
}

type CharacteristicParameters struct {

	// sensitive or case-insensitive keys matching.
	// Determines case-sensitive or case-insensitive keys matching.
	// +kubebuilder:validation:Optional
	CaseInsensitive *bool `json:"caseInsensitive,omitempty" tf:"case_insensitive,omitempty"`

	// (Block List, Max: 1) Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See Rules for more details. (see below for nested schema)
	// Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
	// +kubebuilder:validation:Optional
	KeyCharacteristic []KeyCharacteristicParameters `json:"keyCharacteristic,omitempty" tf:"key_characteristic,omitempty"`

	// (Block List, Max: 1) Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See Rules for more details. (see below for nested schema)
	// Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
	// +kubebuilder:validation:Optional
	SimpleCharacteristic []SimpleCharacteristicParameters `json:"simpleCharacteristic,omitempty" tf:"simple_characteristic,omitempty"`
}

type ConditionAuthorityInitParameters struct {

	// (Block List) (see below for nested schema)
	Authorities []AuthorityAuthoritiesInitParameters `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type ConditionAuthorityObservation struct {

	// (Block List) (see below for nested schema)
	Authorities []AuthorityAuthoritiesObservation `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type ConditionAuthorityParameters struct {

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Authorities []AuthorityAuthoritiesParameters `json:"authorities,omitempty" tf:"authorities,omitempty"`
}

type ConditionHTTPMethodInitParameters struct {

	// (Block List) (see below for nested schema)
	HTTPMethods []HTTPMethodHTTPMethodsInitParameters `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type ConditionHTTPMethodObservation struct {

	// (Block List) (see below for nested schema)
	HTTPMethods []HTTPMethodHTTPMethodsObservation `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type ConditionHTTPMethodParameters struct {

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	HTTPMethods []HTTPMethodHTTPMethodsParameters `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type ConditionHeadersInitParameters struct {

	// (String) The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) String value of the key.
	Value []HeadersValueInitParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type ConditionHeadersObservation struct {

	// (String) The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) String value of the key.
	Value []HeadersValueObservation `json:"value,omitempty" tf:"value,omitempty"`
}

type ConditionHeadersParameters struct {

	// (String) The resource name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) String value of the key.
	// +kubebuilder:validation:Optional
	Value []HeadersValueParameters `json:"value" tf:"value,omitempty"`
}

type ConditionInitParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	Authority []AuthorityInitParameters `json:"authority,omitempty" tf:"authority,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	HTTPMethod []HTTPMethodInitParameters `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	// (Block List) (see below for nested schema)
	Headers []HeadersInitParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	RequestURI []RequestURIInitParameters `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	SourceIP []SourceIPInitParameters `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type ConditionObservation struct {

	// (Block List, Max: 1) (see below for nested schema)
	Authority []AuthorityObservation `json:"authority,omitempty" tf:"authority,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	HTTPMethod []HTTPMethodObservation `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	// (Block List) (see below for nested schema)
	Headers []HeadersObservation `json:"headers,omitempty" tf:"headers,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	RequestURI []RequestURIObservation `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	SourceIP []SourceIPObservation `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type ConditionParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Authority []AuthorityParameters `json:"authority,omitempty" tf:"authority,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	HTTPMethod []HTTPMethodParameters `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Headers []HeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	RequestURI []RequestURIParameters `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	SourceIP []SourceIPParameters `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type ConditionRequestURIInitParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	Path []RequestURIPathInitParameters `json:"path,omitempty" tf:"path,omitempty"`

	// (Block List) (see below for nested schema)
	Queries []RequestURIQueriesInitParameters `json:"queries,omitempty" tf:"queries,omitempty"`
}

type ConditionRequestURIObservation struct {

	// (Block List, Max: 1) (see below for nested schema)
	Path []RequestURIPathObservation `json:"path,omitempty" tf:"path,omitempty"`

	// (Block List) (see below for nested schema)
	Queries []RequestURIQueriesObservation `json:"queries,omitempty" tf:"queries,omitempty"`
}

type ConditionRequestURIParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Path []RequestURIPathParameters `json:"path,omitempty" tf:"path,omitempty"`

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Queries []RequestURIQueriesParameters `json:"queries,omitempty" tf:"queries,omitempty"`
}

type ConditionSourceIPInitParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	GeoIPMatch []SourceIPGeoIPMatchInitParameters `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	GeoIPNotMatch []SourceIPGeoIPNotMatchInitParameters `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	IPRangesMatch []SourceIPIPRangesMatchInitParameters `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	IPRangesNotMatch []SourceIPIPRangesNotMatchInitParameters `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type ConditionSourceIPObservation struct {

	// (Block List, Max: 1) (see below for nested schema)
	GeoIPMatch []SourceIPGeoIPMatchObservation `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	GeoIPNotMatch []SourceIPGeoIPNotMatchObservation `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	IPRangesMatch []SourceIPIPRangesMatchObservation `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	IPRangesNotMatch []SourceIPIPRangesNotMatchObservation `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type ConditionSourceIPParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	GeoIPMatch []SourceIPGeoIPMatchParameters `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	GeoIPNotMatch []SourceIPGeoIPNotMatchParameters `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	IPRangesMatch []SourceIPIPRangesMatchParameters `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	IPRangesNotMatch []SourceIPIPRangesNotMatchParameters `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type DynamicQuotaInitParameters struct {

	// (String) Action in case of exceeding this quota. Possible values: DENY.
	// Action in case of exceeding this quota. Possible values: `DENY`.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Block List) List of characteristics.
	// List of characteristics.
	//
	// ~> Exactly one characteristic specifier: `simple_characteristic` or `key_characteristic` should be specified.
	Characteristic []CharacteristicInitParameters `json:"characteristic,omitempty" tf:"characteristic,omitempty"`

	// (Block List, Max: 1) The condition for matching the rule. You can find all possibilities of condition in gRPC specs. (see below for nested schema)
	// The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
	Condition []ConditionInitParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Number) Desired maximum number of requests per period.
	// Desired maximum number of requests per period.
	Limit *float64 `json:"limit,omitempty" tf:"limit,omitempty"`

	// (Number) Period of time in seconds.
	// Period of time in seconds.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`
}

type DynamicQuotaObservation struct {

	// (String) Action in case of exceeding this quota. Possible values: DENY.
	// Action in case of exceeding this quota. Possible values: `DENY`.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Block List) List of characteristics.
	// List of characteristics.
	//
	// ~> Exactly one characteristic specifier: `simple_characteristic` or `key_characteristic` should be specified.
	Characteristic []CharacteristicObservation `json:"characteristic,omitempty" tf:"characteristic,omitempty"`

	// (Block List, Max: 1) The condition for matching the rule. You can find all possibilities of condition in gRPC specs. (see below for nested schema)
	// The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
	Condition []ConditionObservation `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Number) Desired maximum number of requests per period.
	// Desired maximum number of requests per period.
	Limit *float64 `json:"limit,omitempty" tf:"limit,omitempty"`

	// (Number) Period of time in seconds.
	// Period of time in seconds.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`
}

type DynamicQuotaParameters struct {

	// (String) Action in case of exceeding this quota. Possible values: DENY.
	// Action in case of exceeding this quota. Possible values: `DENY`.
	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Block List) List of characteristics.
	// List of characteristics.
	//
	// ~> Exactly one characteristic specifier: `simple_characteristic` or `key_characteristic` should be specified.
	// +kubebuilder:validation:Optional
	Characteristic []CharacteristicParameters `json:"characteristic,omitempty" tf:"characteristic,omitempty"`

	// (Block List, Max: 1) The condition for matching the rule. You can find all possibilities of condition in gRPC specs. (see below for nested schema)
	// The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
	// +kubebuilder:validation:Optional
	Condition []ConditionParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Number) Desired maximum number of requests per period.
	// Desired maximum number of requests per period.
	// +kubebuilder:validation:Optional
	Limit *float64 `json:"limit,omitempty" tf:"limit,omitempty"`

	// (Number) Period of time in seconds.
	// Period of time in seconds.
	// +kubebuilder:validation:Optional
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`
}

type GeoIPMatchInitParameters struct {

	// (List of String)
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPMatchObservation struct {

	// (List of String)
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPMatchParameters struct {

	// (List of String)
	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPNotMatchInitParameters struct {

	// (List of String)
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPNotMatchObservation struct {

	// (List of String)
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type GeoIPNotMatchParameters struct {

	// (List of String)
	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type HTTPMethodHTTPMethodsInitParameters struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HTTPMethodHTTPMethodsObservation struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HTTPMethodHTTPMethodsParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HTTPMethodInitParameters struct {

	// (Block List) (see below for nested schema)
	HTTPMethods []HTTPMethodsInitParameters `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type HTTPMethodObservation struct {

	// (Block List) (see below for nested schema)
	HTTPMethods []HTTPMethodsObservation `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type HTTPMethodParameters struct {

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	HTTPMethods []HTTPMethodsParameters `json:"httpMethods,omitempty" tf:"http_methods,omitempty"`
}

type HTTPMethodsInitParameters struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HTTPMethodsObservation struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HTTPMethodsParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HeadersInitParameters struct {

	// (String) The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) String value of the key.
	Value []ValueInitParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type HeadersObservation struct {

	// (String) The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) String value of the key.
	Value []ValueObservation `json:"value,omitempty" tf:"value,omitempty"`
}

type HeadersParameters struct {

	// (String) The resource name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) String value of the key.
	// +kubebuilder:validation:Optional
	Value []ValueParameters `json:"value" tf:"value,omitempty"`
}

type HeadersValueInitParameters struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HeadersValueObservation struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type HeadersValueParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type IPRangesMatchInitParameters struct {

	// (List of String)
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesMatchObservation struct {

	// (List of String)
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesMatchParameters struct {

	// (List of String)
	// +kubebuilder:validation:Optional
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesNotMatchInitParameters struct {

	// (List of String)
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesNotMatchObservation struct {

	// (List of String)
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type IPRangesNotMatchParameters struct {

	// (List of String)
	// +kubebuilder:validation:Optional
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type KeyCharacteristicInitParameters struct {

	// (String) Type of key characteristic. Possible values: COOKIE_KEY, HEADER_KEY, QUERY_KEY.
	// Type of key characteristic. Possible values: `COOKIE_KEY`, `HEADER_KEY`, `QUERY_KEY`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) String value of the key.
	// String value of the key.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type KeyCharacteristicObservation struct {

	// (String) Type of key characteristic. Possible values: COOKIE_KEY, HEADER_KEY, QUERY_KEY.
	// Type of key characteristic. Possible values: `COOKIE_KEY`, `HEADER_KEY`, `QUERY_KEY`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) String value of the key.
	// String value of the key.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type KeyCharacteristicParameters struct {

	// (String) Type of key characteristic. Possible values: COOKIE_KEY, HEADER_KEY, QUERY_KEY.
	// Type of key characteristic. Possible values: `COOKIE_KEY`, `HEADER_KEY`, `QUERY_KEY`.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) String value of the key.
	// String value of the key.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PathInitParameters struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type PathObservation struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type PathParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type QueriesInitParameters struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) String value of the key.
	Value []QueriesValueInitParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type QueriesObservation struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) String value of the key.
	Value []QueriesValueObservation `json:"value,omitempty" tf:"value,omitempty"`
}

type QueriesParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (String) String value of the key.
	// +kubebuilder:validation:Optional
	Value []QueriesValueParameters `json:"value" tf:"value,omitempty"`
}

type QueriesValueInitParameters struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type QueriesValueObservation struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type QueriesValueParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIInitParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	Path []PathInitParameters `json:"path,omitempty" tf:"path,omitempty"`

	// (Block List) (see below for nested schema)
	Queries []QueriesInitParameters `json:"queries,omitempty" tf:"queries,omitempty"`
}

type RequestURIObservation struct {

	// (Block List, Max: 1) (see below for nested schema)
	Path []PathObservation `json:"path,omitempty" tf:"path,omitempty"`

	// (Block List) (see below for nested schema)
	Queries []QueriesObservation `json:"queries,omitempty" tf:"queries,omitempty"`
}

type RequestURIParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Path []PathParameters `json:"path,omitempty" tf:"path,omitempty"`

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Queries []QueriesParameters `json:"queries,omitempty" tf:"queries,omitempty"`
}

type RequestURIPathInitParameters struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIPathObservation struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIPathParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIQueriesInitParameters struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) String value of the key.
	Value []RequestURIQueriesValueInitParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type RequestURIQueriesObservation struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) String value of the key.
	Value []RequestURIQueriesValueObservation `json:"value,omitempty" tf:"value,omitempty"`
}

type RequestURIQueriesParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (String) String value of the key.
	// +kubebuilder:validation:Optional
	Value []RequestURIQueriesValueParameters `json:"value" tf:"value,omitempty"`
}

type RequestURIQueriesValueInitParameters struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIQueriesValueObservation struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type RequestURIQueriesValueParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type SimpleCharacteristicInitParameters struct {

	// (String) Type of key characteristic. Possible values: COOKIE_KEY, HEADER_KEY, QUERY_KEY.
	// Type of simple characteristic. Possible values: `REQUEST_PATH`, `HTTP_METHOD`, `IP`, `GEO`, `HOST`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SimpleCharacteristicObservation struct {

	// (String) Type of key characteristic. Possible values: COOKIE_KEY, HEADER_KEY, QUERY_KEY.
	// Type of simple characteristic. Possible values: `REQUEST_PATH`, `HTTP_METHOD`, `IP`, `GEO`, `HOST`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SimpleCharacteristicParameters struct {

	// (String) Type of key characteristic. Possible values: COOKIE_KEY, HEADER_KEY, QUERY_KEY.
	// Type of simple characteristic. Possible values: `REQUEST_PATH`, `HTTP_METHOD`, `IP`, `GEO`, `HOST`.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SourceIPGeoIPMatchInitParameters struct {

	// (List of String)
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPGeoIPMatchObservation struct {

	// (List of String)
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPGeoIPMatchParameters struct {

	// (List of String)
	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPGeoIPNotMatchInitParameters struct {

	// (List of String)
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPGeoIPNotMatchObservation struct {

	// (List of String)
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPGeoIPNotMatchParameters struct {

	// (List of String)
	// +kubebuilder:validation:Optional
	Locations []*string `json:"locations,omitempty" tf:"locations,omitempty"`
}

type SourceIPIPRangesMatchInitParameters struct {

	// (List of String)
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPIPRangesMatchObservation struct {

	// (List of String)
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPIPRangesMatchParameters struct {

	// (List of String)
	// +kubebuilder:validation:Optional
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPIPRangesNotMatchInitParameters struct {

	// (List of String)
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPIPRangesNotMatchObservation struct {

	// (List of String)
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPIPRangesNotMatchParameters struct {

	// (List of String)
	// +kubebuilder:validation:Optional
	IPRanges []*string `json:"ipRanges,omitempty" tf:"ip_ranges,omitempty"`
}

type SourceIPInitParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	GeoIPMatch []GeoIPMatchInitParameters `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	GeoIPNotMatch []GeoIPNotMatchInitParameters `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	IPRangesMatch []IPRangesMatchInitParameters `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	IPRangesNotMatch []IPRangesNotMatchInitParameters `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type SourceIPObservation struct {

	// (Block List, Max: 1) (see below for nested schema)
	GeoIPMatch []GeoIPMatchObservation `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	GeoIPNotMatch []GeoIPNotMatchObservation `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	IPRangesMatch []IPRangesMatchObservation `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	IPRangesNotMatch []IPRangesNotMatchObservation `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type SourceIPParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	GeoIPMatch []GeoIPMatchParameters `json:"geoIpMatch,omitempty" tf:"geo_ip_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	GeoIPNotMatch []GeoIPNotMatchParameters `json:"geoIpNotMatch,omitempty" tf:"geo_ip_not_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	IPRangesMatch []IPRangesMatchParameters `json:"ipRangesMatch,omitempty" tf:"ip_ranges_match,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	IPRangesNotMatch []IPRangesNotMatchParameters `json:"ipRangesNotMatch,omitempty" tf:"ip_ranges_not_match,omitempty"`
}

type StaticQuotaConditionInitParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	Authority []ConditionAuthorityInitParameters `json:"authority,omitempty" tf:"authority,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	HTTPMethod []ConditionHTTPMethodInitParameters `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	// (Block List) (see below for nested schema)
	Headers []ConditionHeadersInitParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	RequestURI []ConditionRequestURIInitParameters `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	SourceIP []ConditionSourceIPInitParameters `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type StaticQuotaConditionObservation struct {

	// (Block List, Max: 1) (see below for nested schema)
	Authority []ConditionAuthorityObservation `json:"authority,omitempty" tf:"authority,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	HTTPMethod []ConditionHTTPMethodObservation `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	// (Block List) (see below for nested schema)
	Headers []ConditionHeadersObservation `json:"headers,omitempty" tf:"headers,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	RequestURI []ConditionRequestURIObservation `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	SourceIP []ConditionSourceIPObservation `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type StaticQuotaConditionParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Authority []ConditionAuthorityParameters `json:"authority,omitempty" tf:"authority,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	HTTPMethod []ConditionHTTPMethodParameters `json:"httpMethod,omitempty" tf:"http_method,omitempty"`

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Headers []ConditionHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	RequestURI []ConditionRequestURIParameters `json:"requestUri,omitempty" tf:"request_uri,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	SourceIP []ConditionSourceIPParameters `json:"sourceIp,omitempty" tf:"source_ip,omitempty"`
}

type StaticQuotaInitParameters struct {

	// (String) Action in case of exceeding this quota. Possible values: DENY.
	// Action in case of exceeding this quota. Possible values: `DENY`.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Block List, Max: 1) The condition for matching the rule. You can find all possibilities of condition in gRPC specs. (see below for nested schema)
	// The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
	Condition []StaticQuotaConditionInitParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Number) Desired maximum number of requests per period.
	// Desired maximum number of requests per period.
	Limit *float64 `json:"limit,omitempty" tf:"limit,omitempty"`

	// (Number) Period of time in seconds.
	// Period of time in seconds.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`
}

type StaticQuotaObservation struct {

	// (String) Action in case of exceeding this quota. Possible values: DENY.
	// Action in case of exceeding this quota. Possible values: `DENY`.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Block List, Max: 1) The condition for matching the rule. You can find all possibilities of condition in gRPC specs. (see below for nested schema)
	// The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
	Condition []StaticQuotaConditionObservation `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Number) Desired maximum number of requests per period.
	// Desired maximum number of requests per period.
	Limit *float64 `json:"limit,omitempty" tf:"limit,omitempty"`

	// (Number) Period of time in seconds.
	// Period of time in seconds.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`
}

type StaticQuotaParameters struct {

	// (String) Action in case of exceeding this quota. Possible values: DENY.
	// Action in case of exceeding this quota. Possible values: `DENY`.
	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Block List, Max: 1) The condition for matching the rule. You can find all possibilities of condition in gRPC specs. (see below for nested schema)
	// The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
	// +kubebuilder:validation:Optional
	Condition []StaticQuotaConditionParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// (Number) Desired maximum number of requests per period.
	// Desired maximum number of requests per period.
	// +kubebuilder:validation:Optional
	Limit *float64 `json:"limit,omitempty" tf:"limit,omitempty"`

	// (Number) Period of time in seconds.
	// Period of time in seconds.
	// +kubebuilder:validation:Optional
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`
}

type ValueInitParameters struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type ValueObservation struct {

	// (String)
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

type ValueParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	ExactMatch *string `json:"exactMatch,omitempty" tf:"exact_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	ExactNotMatch *string `json:"exactNotMatch,omitempty" tf:"exact_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexMatch *string `json:"pireRegexMatch,omitempty" tf:"pire_regex_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PireRegexNotMatch *string `json:"pireRegexNotMatch,omitempty" tf:"pire_regex_not_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixMatch *string `json:"prefixMatch,omitempty" tf:"prefix_match,omitempty"`

	// (String)
	// +kubebuilder:validation:Optional
	PrefixNotMatch *string `json:"prefixNotMatch,omitempty" tf:"prefix_not_match,omitempty"`
}

// AdvancedRateLimiterProfileSpec defines the desired state of AdvancedRateLimiterProfile
type AdvancedRateLimiterProfileSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AdvancedRateLimiterProfileParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider AdvancedRateLimiterProfileInitParameters `json:"initProvider,omitempty"`
}

// AdvancedRateLimiterProfileStatus defines the observed state of AdvancedRateLimiterProfile.
type AdvancedRateLimiterProfileStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AdvancedRateLimiterProfileObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// AdvancedRateLimiterProfile is the Schema for the AdvancedRateLimiterProfiles API. Manage a SWS Advanced Rate Limiter.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type AdvancedRateLimiterProfile struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AdvancedRateLimiterProfileSpec   `json:"spec"`
	Status            AdvancedRateLimiterProfileStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AdvancedRateLimiterProfileList contains a list of AdvancedRateLimiterProfiles
type AdvancedRateLimiterProfileList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AdvancedRateLimiterProfile `json:"items"`
}

// Repository type metadata.
var (
	AdvancedRateLimiterProfile_Kind             = "AdvancedRateLimiterProfile"
	AdvancedRateLimiterProfile_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AdvancedRateLimiterProfile_Kind}.String()
	AdvancedRateLimiterProfile_KindAPIVersion   = AdvancedRateLimiterProfile_Kind + "." + CRDGroupVersion.String()
	AdvancedRateLimiterProfile_GroupVersionKind = CRDGroupVersion.WithKind(AdvancedRateLimiterProfile_Kind)
)

func init() {
	SchemeBuilder.Register(&AdvancedRateLimiterProfile{}, &AdvancedRateLimiterProfileList{})
}
