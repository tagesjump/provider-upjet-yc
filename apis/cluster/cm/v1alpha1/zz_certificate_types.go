// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type CertificateInitParameters struct {

	// (Boolean) The true value means that resource is protected from accidental deletion.
	// The `true` value means that resource is protected from accidental deletion.
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// (String) The resource description.
	// The resource description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (List of String) Domains for this certificate. Should be specified for managed certificates.
	// Domains for this certificate. Should be specified for managed certificates.
	Domains []*string `json:"domains,omitempty" tf:"domains,omitempty"`

	// id is used.
	// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
	// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/cluster/resourcemanager/v1alpha1.Folder
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// (Map of String) A set of key/value label pairs which assigned to resource.
	// A set of key/value label pairs which assigned to resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Block List, Max: 1) Managed specification.
	// Managed specification.
	//
	// ~> Resource creation awaits getting challenges from issue provider.
	Managed []ManagedInitParameters `json:"managed,omitempty" tf:"managed,omitempty"`

	// (String) The resource name.
	// The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// managed specification.
	// Self-managed specification.
	//
	// ~> Only one type `private_key` or `private_key_lockbox_secret` should be specified.
	SelfManaged []SelfManagedInitParameters `json:"selfManaged,omitempty" tf:"self_managed,omitempty"`
}

type CertificateObservation struct {

	// (List of Object) Array of challenges. (see below for nested schema)
	// Array of challenges.
	Challenges []ChallengesObservation `json:"challenges,omitempty" tf:"challenges,omitempty"`

	// (String) The creation timestamp of the resource.
	// The creation timestamp of the resource.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// (Boolean) The true value means that resource is protected from accidental deletion.
	// The `true` value means that resource is protected from accidental deletion.
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// (String) The resource description.
	// The resource description.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (List of String) Domains for this certificate. Should be specified for managed certificates.
	// Domains for this certificate. Should be specified for managed certificates.
	Domains []*string `json:"domains,omitempty" tf:"domains,omitempty"`

	// id is used.
	// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Certificate issue timestamp.
	// Certificate issue timestamp.
	IssuedAt *string `json:"issuedAt,omitempty" tf:"issued_at,omitempty"`

	// (String) Certificate Issuer.
	// Certificate Issuer.
	Issuer *string `json:"issuer,omitempty" tf:"issuer,omitempty"`

	// (Map of String) A set of key/value label pairs which assigned to resource.
	// A set of key/value label pairs which assigned to resource.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Block List, Max: 1) Managed specification.
	// Managed specification.
	//
	// ~> Resource creation awaits getting challenges from issue provider.
	Managed []ManagedObservation `json:"managed,omitempty" tf:"managed,omitempty"`

	// (String) The resource name.
	// The resource name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Certificate end valid period.
	// Certificate end valid period.
	NotAfter *string `json:"notAfter,omitempty" tf:"not_after,omitempty"`

	// (String) Certificate start valid period.
	// Certificate start valid period.
	NotBefore *string `json:"notBefore,omitempty" tf:"not_before,omitempty"`

	// managed specification.
	// Self-managed specification.
	//
	// ~> Only one type `private_key` or `private_key_lockbox_secret` should be specified.
	SelfManaged []SelfManagedObservation `json:"selfManaged,omitempty" tf:"self_managed,omitempty"`

	// (String) Certificate Serial Number.
	// Certificate Serial Number.
	Serial *string `json:"serial,omitempty" tf:"serial,omitempty"`

	// (String) Certificate status: VALIDATING, INVALID, ISSUED, REVOKED, RENEWING or RENEWAL_FAILED.
	// Certificate status: `VALIDATING`, `INVALID`, `ISSUED`, `REVOKED`, `RENEWING` or `RENEWAL_FAILED`.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// (String) Certificate Subject.
	// Certificate Subject.
	Subject *string `json:"subject,omitempty" tf:"subject,omitempty"`

	// (String) Certificate type: MANAGED or IMPORTED.
	// Certificate type: `MANAGED` or `IMPORTED`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) Certificate update timestamp.
	// Certificate update timestamp.
	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type CertificateParameters struct {

	// (Boolean) The true value means that resource is protected from accidental deletion.
	// The `true` value means that resource is protected from accidental deletion.
	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// (String) The resource description.
	// The resource description.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (List of String) Domains for this certificate. Should be specified for managed certificates.
	// Domains for this certificate. Should be specified for managed certificates.
	// +kubebuilder:validation:Optional
	Domains []*string `json:"domains,omitempty" tf:"domains,omitempty"`

	// id is used.
	// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
	// +crossplane:generate:reference:type=github.com/tagesjump/provider-upjet-yc/apis/cluster/resourcemanager/v1alpha1.Folder
	// +kubebuilder:validation:Optional
	FolderID *string `json:"folderId,omitempty" tf:"folder_id,omitempty"`

	// Reference to a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDRef *v1.Reference `json:"folderIdRef,omitempty" tf:"-"`

	// Selector for a Folder in resourcemanager to populate folderId.
	// +kubebuilder:validation:Optional
	FolderIDSelector *v1.Selector `json:"folderIdSelector,omitempty" tf:"-"`

	// (Map of String) A set of key/value label pairs which assigned to resource.
	// A set of key/value label pairs which assigned to resource.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Block List, Max: 1) Managed specification.
	// Managed specification.
	//
	// ~> Resource creation awaits getting challenges from issue provider.
	// +kubebuilder:validation:Optional
	Managed []ManagedParameters `json:"managed,omitempty" tf:"managed,omitempty"`

	// (String) The resource name.
	// The resource name.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// managed specification.
	// Self-managed specification.
	//
	// ~> Only one type `private_key` or `private_key_lockbox_secret` should be specified.
	// +kubebuilder:validation:Optional
	SelfManaged []SelfManagedParameters `json:"selfManaged,omitempty" tf:"self_managed,omitempty"`
}

type ChallengesInitParameters struct {
}

type ChallengesObservation struct {

	// (String) The creation timestamp of the resource.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// (String)
	DNSName *string `json:"dnsName,omitempty" tf:"dns_name,omitempty"`

	// (String)
	DNSType *string `json:"dnsType,omitempty" tf:"dns_type,omitempty"`

	// (String)
	DNSValue *string `json:"dnsValue,omitempty" tf:"dns_value,omitempty"`

	// (String)
	Domain *string `json:"domain,omitempty" tf:"domain,omitempty"`

	// (String)
	HTTPContent *string `json:"httpContent,omitempty" tf:"http_content,omitempty"`

	// (String)
	HTTPURL *string `json:"httpUrl,omitempty" tf:"http_url,omitempty"`

	// (String)
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// (String) Certificate type: MANAGED or IMPORTED.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) Certificate update timestamp.
	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type ChallengesParameters struct {
}

type ManagedInitParameters struct {

	// domain certificates.
	// Expected number of challenge count needed to validate certificate. Resource creation will fail if the specified value does not match the actual number of challenges received from issue provider. This argument is helpful for safe automatic resource creation for passing challenges for multi-domain certificates.
	ChallengeCount *float64 `json:"challengeCount,omitempty" tf:"challenge_count,omitempty"`

	// check method. Possible values:
	// Domain owner-check method. Possible values:
	// * `DNS_CNAME` - you will need to create a CNAME dns record with the specified value. Recommended for fully automated certificate renewal.
	// * `DNS_TXT` - you will need to create a TXT dns record with specified value.
	// * `HTTP` - you will need to place specified value into specified url.
	ChallengeType *string `json:"challengeType,omitempty" tf:"challenge_type,omitempty"`
}

type ManagedObservation struct {

	// domain certificates.
	// Expected number of challenge count needed to validate certificate. Resource creation will fail if the specified value does not match the actual number of challenges received from issue provider. This argument is helpful for safe automatic resource creation for passing challenges for multi-domain certificates.
	ChallengeCount *float64 `json:"challengeCount,omitempty" tf:"challenge_count,omitempty"`

	// check method. Possible values:
	// Domain owner-check method. Possible values:
	// * `DNS_CNAME` - you will need to create a CNAME dns record with the specified value. Recommended for fully automated certificate renewal.
	// * `DNS_TXT` - you will need to create a TXT dns record with specified value.
	// * `HTTP` - you will need to place specified value into specified url.
	ChallengeType *string `json:"challengeType,omitempty" tf:"challenge_type,omitempty"`
}

type ManagedParameters struct {

	// domain certificates.
	// Expected number of challenge count needed to validate certificate. Resource creation will fail if the specified value does not match the actual number of challenges received from issue provider. This argument is helpful for safe automatic resource creation for passing challenges for multi-domain certificates.
	// +kubebuilder:validation:Optional
	ChallengeCount *float64 `json:"challengeCount,omitempty" tf:"challenge_count,omitempty"`

	// check method. Possible values:
	// Domain owner-check method. Possible values:
	// * `DNS_CNAME` - you will need to create a CNAME dns record with the specified value. Recommended for fully automated certificate renewal.
	// * `DNS_TXT` - you will need to create a TXT dns record with specified value.
	// * `HTTP` - you will need to place specified value into specified url.
	// +kubebuilder:validation:Optional
	ChallengeType *string `json:"challengeType" tf:"challenge_type,omitempty"`
}

type PrivateKeyLockboxSecretInitParameters struct {

	// (String) The ID of this resource.
	// Lockbox secret Id.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Key of the Lockbox secret, the value of which contains the private key of the certificate.
	// Key of the Lockbox secret, the value of which contains the private key of the certificate.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`
}

type PrivateKeyLockboxSecretObservation struct {

	// (String) The ID of this resource.
	// Lockbox secret Id.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Key of the Lockbox secret, the value of which contains the private key of the certificate.
	// Key of the Lockbox secret, the value of which contains the private key of the certificate.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`
}

type PrivateKeyLockboxSecretParameters struct {

	// (String) The ID of this resource.
	// Lockbox secret Id.
	// +kubebuilder:validation:Optional
	ID *string `json:"id" tf:"id,omitempty"`

	// (String) Key of the Lockbox secret, the value of which contains the private key of the certificate.
	// Key of the Lockbox secret, the value of which contains the private key of the certificate.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`
}

type SelfManagedInitParameters struct {

	// (String) Certificate with chain.
	// Certificate with chain.
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// (Block List, Max: 1) Lockbox secret specification for getting private key. (see below for nested schema)
	// Lockbox secret specification for getting private key.
	PrivateKeyLockboxSecret []PrivateKeyLockboxSecretInitParameters `json:"privateKeyLockboxSecret,omitempty" tf:"private_key_lockbox_secret,omitempty"`

	// (String, Sensitive) Private key of certificate.
	// Private key of certificate.
	PrivateKeySecretRef *v1.SecretKeySelector `json:"privateKeySecretRef,omitempty" tf:"-"`
}

type SelfManagedObservation struct {

	// (String) Certificate with chain.
	// Certificate with chain.
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// (Block List, Max: 1) Lockbox secret specification for getting private key. (see below for nested schema)
	// Lockbox secret specification for getting private key.
	PrivateKeyLockboxSecret []PrivateKeyLockboxSecretObservation `json:"privateKeyLockboxSecret,omitempty" tf:"private_key_lockbox_secret,omitempty"`
}

type SelfManagedParameters struct {

	// (String) Certificate with chain.
	// Certificate with chain.
	// +kubebuilder:validation:Optional
	Certificate *string `json:"certificate" tf:"certificate,omitempty"`

	// (Block List, Max: 1) Lockbox secret specification for getting private key. (see below for nested schema)
	// Lockbox secret specification for getting private key.
	// +kubebuilder:validation:Optional
	PrivateKeyLockboxSecret []PrivateKeyLockboxSecretParameters `json:"privateKeyLockboxSecret,omitempty" tf:"private_key_lockbox_secret,omitempty"`

	// (String, Sensitive) Private key of certificate.
	// Private key of certificate.
	// +kubebuilder:validation:Optional
	PrivateKeySecretRef *v1.SecretKeySelector `json:"privateKeySecretRef,omitempty" tf:"-"`
}

// CertificateSpec defines the desired state of Certificate
type CertificateSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     CertificateParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider CertificateInitParameters `json:"initProvider,omitempty"`
}

// CertificateStatus defines the observed state of Certificate.
type CertificateStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        CertificateObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Certificate is the Schema for the Certificates API. A TLS certificate signed by a certification authority confirming that it belongs to the owner of the domain name.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,yandex-cloud}
type Certificate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   CertificateSpec   `json:"spec"`
	Status CertificateStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CertificateList contains a list of Certificates
type CertificateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Certificate `json:"items"`
}

// Repository type metadata.
var (
	Certificate_Kind             = "Certificate"
	Certificate_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Certificate_Kind}.String()
	Certificate_KindAPIVersion   = Certificate_Kind + "." + CRDGroupVersion.String()
	Certificate_GroupVersionKind = CRDGroupVersion.WithKind(Certificate_Kind)
)

func init() {
	SchemeBuilder.Register(&Certificate{}, &CertificateList{})
}
